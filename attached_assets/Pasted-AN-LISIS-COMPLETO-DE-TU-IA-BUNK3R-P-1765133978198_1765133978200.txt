ANÁLISIS COMPLETO DE TU IA BUNK3R ════════════════════════════════════════════════════════════════ PARTE 1: LO QUE TU IA YA TIENE (BIEN HECHO) ════════════════════════════════════════════════════════════════ Sistema de 8 fases en ai_constructor.py: Fase	Componente	Función	Estado 1	IntentParser	Analiza qué quiere el usuario	✅ Funciona 2	ResearchEngine	Investiga mejores prácticas por contexto	✅ Funciona 3	ClarificationManager	Pregunta si falta información	✅ Funciona 4	PromptBuilder	Construye prompt maestro detallado	✅ Funciona 5	TaskOrchestrator	Crea plan de tareas	✅ Funciona 6	TaskOrchestrator	Ejecuta generación de código	✅ Funciona 7	OutputVerifier	Verifica calidad del código	✅ Funciona 8	AIConstructorService	Entrega archivos finales	✅ Funciona Multi-proveedor IA en ai_service.py: ORDEN DE PRIORIDAD: 1. Groq (llama-3.3-70b-versatile)     → Más rápido 2. Cerebras (llama-3.3-70b)           → Backup rápido 3. Gemini (gemini-2.0-flash)          → Google 4. DeepSeek (deepseek-chat)           → Económico 5. HuggingFace (Meta-Llama-3-8B)      → Fallback CARACTERÍSTICAS: ✅ Fallback automático si un proveedor falla ✅ Auto-rectificación de respuestas malas ✅ Detección de problemas en respuestas ✅ Historial de conversación por usuario ✅ Contexto diferenciado (owner/admin/usuario) Tipos de tareas que detecta: class TaskType(Enum): CREAR_WEB = "crear_web"           # ✅ Funciona CREAR_LANDING = "crear_landing"   # ✅ Funciona CREAR_DASHBOARD = "crear_dashboard" # ✅ Funciona CREAR_FORMULARIO = "crear_formulario" # ✅ Funciona CREAR_API = "crear_api"           # ⚠️ Genera HTML en vez de Python MODIFICAR_CODIGO = "modificar_codigo" # ❌ No funciona CORREGIR_ERROR = "corregir_error" # ❌ No funciona OPTIMIZAR = "optimizar"           # ❌ No funciona EXPLICAR = "explicar"             # ⚠️ Solo texto CONSULTA_GENERAL = "consulta_general" # ⚠️ Solo texto Contextos de negocio que reconoce: restaurante, ecommerce, portfolio, blog, saas, fintech, negocio ════════════════════════════════════════════════════════════════ PARTE 2: CÓMO DEBERÍA ACTUAR TU IA (FLUJO IDEAL) ════════════════════════════════════════════════════════════════ FLUJO IDEAL PARA CUALQUIER PETICIÓN: ┌─────────────────────────────────────────────────────────────────┐ │  USUARIO DICE: "Agrega sistema de login a mi app"              │ ├─────────────────────────────────────────────────────────────────┤ │                                                                 │ │  FASE 1: ENTENDER EL CONTEXTO                                  │ │  ├── [IA] Leo la estructura del proyecto                       │ │  │   └── ls -la → Ver qué archivos hay                         │ │  ├── [IA] Leo el archivo principal                             │ │  │   └── read app.py → Ver cómo está organizado                │ │  ├── [IA] Leo las dependencias                                 │ │  │   └── read requirements.txt → Ver qué librerías hay         │ │  ├── [IA] Busco si ya existe auth                              │ │  │   └── grep "login|auth|session" . → Buscar en código        │ │  └── [IA] Entiendo: Es Flask con PostgreSQL                    │ │                                                                 │ │  FASE 2: ANALIZAR LA PETICIÓN                                  │ │  ├── [IA] Detecto intención: CREAR_FEATURE                     │ │  ├── [IA] Tipo: Sistema de autenticación                       │ │  ├── [IA] Lenguaje: Python/Flask                               │ │  └── [IA] Necesito: JWT, bcrypt, endpoints, middleware         │ │                                                                 │ │  FASE 3: CLARIFICAR SI HACE FALTA                              │ │  └── [IA] "¿Quieres login con email/contraseña, Google, o      │ │            ambos? ¿Necesitas recuperación de contraseña?"      │ │  └── [Usuario] "Email/contraseña con recuperación"             │ │                                                                 │ │  FASE 4: CREAR PLAN                                            │ │  └── [IA] "Voy a hacer esto:"                                  │ │      ├── 1. Instalar dependencias (PyJWT, bcrypt)              │ │      ├── 2. Crear modelo User en tracking/models.py            │ │      ├── 3. Crear tracking/auth.py con lógica                  │ │      ├── 4. Agregar endpoints en app.py                        │ │      ├── 5. Crear templates login.html, register.html          │ │      └── 6. Proteger rutas existentes                          │ │  └── [IA] "¿Procedo? (sí/no/ajustar)"                          │ │  └── [Usuario] "sí"                                            │ │                                                                 │ │  FASE 5: EJECUTAR PASO A PASO                                  │ │  ├── [IA] "Instalando dependencias..."                         │ │  │   └── run: pip install PyJWT bcrypt                         │ │  │   └── ✅ Instalado correctamente                            │ │  ├── [IA] "Creando modelo User..."                             │ │  │   └── edit tracking/models.py → Agregar clase User          │ │  │   └── ✅ Modelo creado                                      │ │  ├── [IA] "Creando servicio de auth..."                        │ │  │   └── create tracking/auth.py → Lógica completa             │ │  │   └── ✅ Servicio creado                                    │ │  ├── [IA] "Agregando endpoints..."                             │ │  │   └── edit app.py → Agregar /login, /register, /logout      │ │  │   └── ✅ Endpoints agregados                                │ │  └── [IA] "Creando templates..."                               │ │      └── create templates/login.html                           │ │      └── create templates/register.html                        │ │      └── ✅ Templates creados                                  │ │                                                                 │ │  FASE 6: VERIFICAR                                             │ │  ├── [IA] "Reiniciando servidor..."                            │ │  │   └── restart server                                        │ │  ├── [IA] "Leyendo logs..."                                    │ │  │   └── read_logs → Buscar errores                            │ │  │   └── ❌ Error: ModuleNotFoundError: flask_login            │ │  ├── [IA] "Corrigiendo error..."                               │ │  │   └── run: pip install flask-login                          │ │  │   └── restart server                                        │ │  │   └── read_logs → Sin errores                               │ │  └── ✅ Todo funcionando                                       │ │                                                                 │ │  FASE 7: ENTREGAR                                              │ │  └── [IA] "✅ Sistema de login implementado"                   │ │      ├── Archivos creados: auth.py, login.html, register.html  │ │      ├── Archivos modificados: models.py, app.py               │ │      ├── Dependencias instaladas: PyJWT, bcrypt, flask-login   │ │      └── Endpoints nuevos: /login, /register, /logout          │ │                                                                 │ └─────────────────────────────────────────────────────────────────┘ ════════════════════════════════════════════════════════════════ PARTE 3: LO QUE TU IA NO HACE (CRÍTICO) ════════════════════════════════════════════════════════════════ HERRAMIENTAS QUE LE FALTAN: ┌──────────────────────────────────────────────────────────────────┐ │  HERRAMIENTA          │ QUÉ HACE                    │ ESTADO    │ ├──────────────────────────────────────────────────────────────────┤ │  read_file(path)      │ Leer cualquier archivo      │ ❌ FALTA  │ │  write_file(path,c)   │ Crear archivo nuevo         │ ⚠️ SOLO HTML│ │  edit_file(path,o,n)  │ Editar parte de archivo     │ ❌ FALTA  │ │  delete_file(path)    │ Eliminar archivo            │ ❌ FALTA  │ │  list_dir(path)       │ Ver estructura carpetas     │ ❌ FALTA  │ │  search_code(query)   │ Buscar en código (grep)     │ ❌ FALTA  │ │  run_command(cmd)     │ Ejecutar comandos           │ ❌ FALTA  │ │  read_logs()          │ Leer logs del servidor      │ ❌ FALTA  │ │  detect_errors()      │ Encontrar errores           │ ❌ FALTA  │ │  analyze_project()    │ Entender el proyecto        │ ❌ FALTA  │ │  take_screenshot()    │ Ver resultado visual        │ ❌ FALTA  │ │  install_package()    │ npm/pip install             │ ❌ FALTA  │ └──────────────────────────────────────────────────────────────────┘ INTENCIONES QUE NO ENTIENDE: PETICIÓN DEL USUARIO              │ LO QUE DEBERÍA HACER        │ LO QUE HACE ──────────────────────────────────┼─────────────────────────────┼───────────────── "Modifica el header de index.html"│ Leer archivo, editar header │ ❌ No puede "Arregla este error: NameError"   │ Analizar, corregir código   │ ❌ No puede "Ejecuta npm install express"     │ Ejecutar comando            │ ❌ No puede "Muéstrame cómo está app.py"      │ Leer y mostrar archivo      │ ❌ No puede "¿Por qué falla el login?"        │ Leer logs, analizar         │ ❌ No puede "Agrega esta función a utils.js"  │ Leer archivo, agregar código│ ❌ No puede "Instala Flask y SQLAlchemy"      │ pip install                 │ ❌ No puede "Crea una API en Python"          │ Generar código Python       │ ⚠️ Genera HTML "Refactoriza este código"         │ Leer, analizar, reescribir  │ ❌ No puede "Busca dónde usamos getUserId"    │ grep en todo el código      │ ❌ No puede PROBLEMAS ESPECÍFICOS: 1. SOLO GENERA HTML/CSS/JS └── Si le pides una API, genera un formulario HTML └── No sabe generar Python, Node.js, SQL, etc. 2. NO LEE EL PROYECTO └── No sabe qué archivos existen └── No entiende la estructura └── No puede adaptar su respuesta al contexto 3. NO EDITA, SOLO REEMPLAZA └── Si quieres cambiar una línea, genera todo de nuevo └── Pierde el código existente 4. NO EJECUTA NADA └── No puede instalar dependencias └── No puede correr scripts └── No puede reiniciar el servidor 5. NO VE ERRORES └── Si algo falla, no sabe └── No puede leer logs └── No puede auto-corregir 6. NO TIENE MEMORIA DEL PROYECTO └── Cada petición empieza de cero └── No recuerda qué archivos creó antes ════════════════════════════════════════════════════════════════ PARTE 4: MEJORAS DETALLADAS QUE NECESITA ════════════════════════════════════════════════════════════════ MEJORA 1: SISTEMA DE HERRAMIENTAS (TOOLS) class AIToolkit: """ Herramientas que la IA puede usar. INSPIRADO EN: Replit Agent tools (read, write, edit, bash, grep) """ # ═══════════════════════════════════════════════════════════ # LECTURA DE ARCHIVOS # ═══════════════════════════════════════════════════════════ def read_file(self, path: str, limit: int = 1000) -> str: """ Lee el contenido de un archivo. Uso: - Antes de editar, SIEMPRE leer primero - Para entender código existente - Para ver qué hay en el proyecto Ejemplo: content = toolkit.read_file("app.py") content = toolkit.read_file("static/js/app.js", limit=500) """ pass def list_directory(self, path: str = ".", recursive: bool = True) -> List[str]: """ Lista archivos y carpetas. Uso: - Para entender estructura del proyecto - Para encontrar archivos Ejemplo: files = toolkit.list_directory(".")  # Todo el proyecto files = toolkit.list_directory("static/js")  # Solo JS """ pass def search_code(self, pattern: str, path: str = ".", file_type: str = None) -> List[Dict]: """ Busca texto/patrón en archivos (como grep). Uso: - Encontrar dónde se usa una función - Buscar imports - Encontrar errores Ejemplo: matches = toolkit.search_code("def login", ".") matches = toolkit.search_code("import flask", ".", file_type="py") matches = toolkit.search_code("getUserId", "static/js") """ pass # ═══════════════════════════════════════════════════════════ # ESCRITURA Y EDICIÓN DE ARCHIVOS # ═══════════════════════════════════════════════════════════ def write_file(self, path: str, content: str) -> bool: """ Crea o sobrescribe un archivo. Uso: - Crear archivos nuevos - Sobrescribir archivos pequeños IMPORTANTE: Para archivos existentes, usar edit_file Ejemplo: toolkit.write_file("tracking/auth.py", auth_code) toolkit.write_file("config.json", json.dumps(config)) """ pass def edit_file(self, path: str, old_string: str, new_string: str) -> bool: """ Edita una sección específica de un archivo. CRÍTICO: Esta es la herramienta más importante. Permite modificar código sin perder el resto. Uso: - Agregar imports - Modificar funciones - Corregir errores - Agregar código nuevo Ejemplo: # Agregar un import toolkit.edit_file("app.py", "from flask import Flask", "from flask import Flask\\nfrom flask_login import LoginManager" ) # Corregir un error toolkit.edit_file("app.py", "def login():", "def login():\\n    # Ahora con validación" ) """ pass def append_to_file(self, path: str, content: str) -> bool: """ Agrega contenido al final de un archivo. Uso: - Agregar nuevas funciones - Agregar nuevas rutas - Agregar al final de CSS Ejemplo: toolkit.append_to_file("app.py", new_route_code) toolkit.append_to_file("static/css/styles.css", new_styles) """ pass def delete_file(self, path: str, confirm: bool = True) -> bool: """ Elimina un archivo. SEGURIDAD: Siempre pedir confirmación al usuario. Ejemplo: toolkit.delete_file("temp.py") """ pass def create_directory(self, path: str) -> bool: """ Crea una carpeta. Ejemplo: toolkit.create_directory("tracking/auth") toolkit.create_directory("static/uploads") """ pass # ═══════════════════════════════════════════════════════════ # EJECUCIÓN DE COMANDOS # ═══════════════════════════════════════════════════════════ def run_command(self, command: str, timeout: int = 60) -> Dict: """ Ejecuta un comando del sistema. SEGURIDAD: Solo comandos de la whitelist. Retorna: { "success": True/False, "stdout": "output...", "stderr": "errors...", "exit_code": 0 } Ejemplo: result = toolkit.run_command("pip install flask-login") result = toolkit.run_command("npm install express") result = toolkit.run_command("python -c 'print(1+1)'") """ pass def install_package(self, name: str, manager: str = "auto") -> bool: """ Instala un paquete. manager: "pip", "npm", "auto" (detecta según proyecto) Ejemplo: toolkit.install_package("flask-login") toolkit.install_package("express", manager="npm") """ pass # ═══════════════════════════════════════════════════════════ # LECTURA DE LOGS Y ERRORES # ═══════════════════════════════════════════════════════════ def read_server_logs(self, lines: int = 100) -> List[str]: """ Lee los logs del servidor. Uso: - Ver si hay errores - Debuggear problemas - Verificar que algo funciona Ejemplo: logs = toolkit.read_server_logs(50) """ pass def detect_errors(self, logs: List[str] = None) -> List[Dict]: """ Detecta errores en logs. Retorna: [ { "type": "ModuleNotFoundError", "message": "No module named 'flask_login'", "file": "app.py", "line": 5, "suggestion": "pip install flask-login" } ] """ pass def analyze_error(self, error: str) -> Dict: """ Analiza un error y sugiere solución. Usa la IA para entender el error y proponer fix. Retorna: { "cause": "Falta el módulo flask_login", "solution": "Instalar con pip install flask-login", "auto_fix_available": True, "fix_commands": ["pip install flask-login"] } """ pass # ═══════════════════════════════════════════════════════════ # ANÁLISIS DEL PROYECTO # ═══════════════════════════════════════════════════════════ def analyze_project(self) -> Dict: """ Analiza el proyecto completo. Retorna: { "language": "python", "framework": "flask", "dependencies": ["flask", "sqlalchemy"], "entry_point": "app.py", "structure": { "app.py": "main", "tracking/": "services", "templates/": "views", "static/": "assets" }, "database": "postgresql", "has_tests": False } """ pass def get_file_info(self, path: str) -> Dict: """ Obtiene información de un archivo. Retorna: { "exists": True, "size": 1234, "lines": 56, "language": "python", "last_modified": "2025-12-07 20:00:00" } """ pass MEJORA 2: SISTEMA DE INTENCIONES EXPANDIDO class TaskType(Enum): """ TODOS los tipos de tareas que la IA debe entender. EXPANDIDO de 10 a 25+ tipos. """ # ═══════════════════════════════════════════════════════════ # CREACIÓN (ya funcionan parcialmente) # ═══════════════════════════════════════════════════════════ CREAR_PROYECTO = "crear_proyecto"      # "Crea un proyecto de..." CREAR_WEB = "crear_web"                # "Crea una página web" CREAR_LANDING = "crear_landing"        # "Crea un landing page" CREAR_DASHBOARD = "crear_dashboard"    # "Crea un dashboard" CREAR_FORMULARIO = "crear_formulario"  # "Crea un formulario" CREAR_API = "crear_api"                # "Crea una API" → DEBE GENERAR PYTHON/NODE CREAR_COMPONENTE = "crear_componente"  # "Crea un componente de..." CREAR_ARCHIVO = "crear_archivo"        # "Crea un archivo nuevo" # ═══════════════════════════════════════════════════════════ # MODIFICACIÓN (NO FUNCIONAN - CRÍTICO) # ═══════════════════════════════════════════════════════════ MODIFICAR_ARCHIVO = "modificar_archivo"    # "Modifica app.py" AGREGAR_CODIGO = "agregar_codigo"          # "Agrega esta función a..." ELIMINAR_CODIGO = "eliminar_codigo"        # "Quita esta parte de..." REEMPLAZAR_CODIGO = "reemplazar_codigo"    # "Cambia X por Y" MOVER_ARCHIVO = "mover_archivo"            # "Mueve este archivo a..." RENOMBRAR = "renombrar"                    # "Renombra X a Y" # ═══════════════════════════════════════════════════════════ # CORRECCIÓN Y DEBUGGING (NO FUNCIONAN - CRÍTICO) # ═══════════════════════════════════════════════════════════ CORREGIR_ERROR = "corregir_error"          # "Arregla este error" DEBUGGEAR = "debuggear"                    # "¿Por qué no funciona?" ANALIZAR_LOGS = "analizar_logs"            # "Revisa los logs" BUSCAR_BUG = "buscar_bug"                  # "Encuentra el problema" # ═══════════════════════════════════════════════════════════ # EJECUCIÓN (NO FUNCIONAN - CRÍTICO) # ═══════════════════════════════════════════════════════════ EJECUTAR_COMANDO = "ejecutar_comando"      # "Ejecuta npm install" INSTALAR_DEPENDENCIA = "instalar_dep"      # "Instala flask-login" CORRER_SCRIPT = "correr_script"            # "Corre python test.py" REINICIAR_SERVIDOR = "reiniciar_servidor"  # "Reinicia el servidor" # ═══════════════════════════════════════════════════════════ # LECTURA Y BÚSQUEDA (NO FUNCIONAN - CRÍTICO) # ═══════════════════════════════════════════════════════════ LEER_ARCHIVO = "leer_archivo"              # "Muéstrame app.py" BUSCAR_CODIGO = "buscar_codigo"            # "Busca dónde usamos X" LISTAR_ARCHIVOS = "listar_archivos"        # "¿Qué archivos hay?" VER_ESTRUCTURA = "ver_estructura"          # "Muestra la estructura" # ═══════════════════════════════════════════════════════════ # OPTIMIZACIÓN Y MEJORA # ═══════════════════════════════════════════════════════════ OPTIMIZAR = "optimizar"                    # "Optimiza este código" REFACTORIZAR = "refactorizar"              # "Refactoriza esto" LIMPIAR_CODIGO = "limpiar_codigo"          # "Limpia el código" MEJORAR = "mejorar"                        # "Mejora esto" # ═══════════════════════════════════════════════════════════ # EXPLICACIÓN Y DOCUMENTACIÓN # ═══════════════════════════════════════════════════════════ EXPLICAR = "explicar"                      # "Explica este código" DOCUMENTAR = "documentar"                  # "Documenta esta función" COMENTAR = "comentar"                      # "Agrega comentarios" # ═══════════════════════════════════════════════════════════ # TESTING # ═══════════════════════════════════════════════════════════ CREAR_TEST = "crear_test"                  # "Crea tests para..." CORRER_TESTS = "correr_tests"              # "Corre los tests" # ═══════════════════════════════════════════════════════════ # BASE DE DATOS # ═══════════════════════════════════════════════════════════ CREAR_TABLA = "crear_tabla"                # "Crea tabla users" MODIFICAR_TABLA = "modificar_tabla"        # "Agrega columna a..." QUERY_SQL = "query_sql"                    # "Ejecuta este SQL" # ═══════════════════════════════════════════════════════════ # GENERAL # ═══════════════════════════════════════════════════════════ CONSULTA_GENERAL = "consulta_general"      # Preguntas generales DESCONOCIDO = "desconocido"                # No se entiende MEJORA 3: PATRONES PARA DETECTAR INTENCIONES class IntentPatterns: """ Patrones regex para detectar qué quiere el usuario. """ PATTERNS = { # CREAR TaskType.CREAR_ARCHIVO: [ r"crea(?:r?)?\s+(?:un\s+)?archivo", r"genera(?:r?)?\s+(?:un\s+)?archivo", r"hazme?\s+(?:un\s+)?archivo", ], # MODIFICAR TaskType.MODIFICAR_ARCHIVO: [ r"modifica(?:r?)?\s+(?:el\s+)?(\w+\.?\w*)", r"cambia(?:r?)?\s+(?:en\s+)?(\w+\.?\w*)", r"actualiza(?:r?)?\s+(?:el\s+)?(\w+\.?\w*)", r"edita(?:r?)?\s+(?:el\s+)?(\w+\.?\w*)", ], TaskType.AGREGAR_CODIGO: [ r"agrega(?:r?)?\s+(?:esto\s+)?(?:a|en)\s+(\w+\.?\w*)", r"añade(?:r?)?\s+(?:esto\s+)?(?:a|en)\s+(\w+\.?\w*)", r"pon(?:er?)?\s+(?:esto\s+)?(?:en)\s+(\w+\.?\w*)", ], # CORREGIR TaskType.CORREGIR_ERROR: [ r"arregla(?:r?)?\s+(?:el\s+)?error", r"corrige(?:r?)?\s+(?:el\s+)?error", r"fix(?:ear?)?\s+(?:el\s+)?(?:error|bug)", r"no\s+funciona", r"está\s+(?:roto|mal|fallando)", ], # EJECUTAR TaskType.EJECUTAR_COMANDO: [ r"ejecuta(?:r?)?\s+(.+)", r"corre(?:r?)?\s+(.+)", r"run\s+(.+)", ], TaskType.INSTALAR_DEPENDENCIA: [ r"instala(?:r?)?\s+(\w+)", r"(?:pip|npm)\s+install\s+(\w+)", r"agrega(?:r?)?\s+(?:la\s+)?dependencia\s+(\w+)", ], # LEER TaskType.LEER_ARCHIVO: [ r"muestra(?:me?)?\s+(?:el\s+)?(\w+\.?\w*)", r"enséñame?\s+(?:el\s+)?(\w+\.?\w*)", r"(?:qué\s+hay|cómo\s+está)\s+(?:en\s+)?(\w+\.?\w*)", r"lee(?:r?)?\s+(?:el\s+)?(\w+\.?\w*)", r"ver\s+(?:el\s+)?(\w+\.?\w*)", ], TaskType.BUSCAR_CODIGO: [ r"busca(?:r?)?\s+(?:dónde\s+)?(.+)", r"encuentra(?:r?)?\s+(.+)", r"(?:dónde|donde)\s+(?:está|usamos|se\s+usa)\s+(.+)", ], # EXPLICAR TaskType.EXPLICAR: [ r"explica(?:me?)?\s+(.+)", r"(?:qué|que)\s+(?:es|hace|significa)\s+(.+)", r"(?:cómo|como)\s+funciona\s+(.+)", r"(?:por\s+qué|porque)\s+(.+)", ], } MEJORA 4: FLUJO DE EJECUCIÓN MEJORADO class AIExecutionFlow: """ Cómo debería ejecutar cada tipo de tarea. """ FLOWS = { TaskType.MODIFICAR_ARCHIVO: [ ("read_file", "Leer archivo actual"), ("analyze", "Entender qué cambiar"), ("plan", "Crear plan de cambios"), ("confirm", "Pedir confirmación"), ("edit_file", "Aplicar cambios"), ("verify", "Verificar que funciona"), ("report", "Reportar resultado"), ], TaskType.CORREGIR_ERROR: [ ("read_logs", "Leer logs del servidor"), ("detect_error", "Identificar el error"), ("analyze_error", "Analizar causa"), ("search_code", "Encontrar código problemático"), ("plan_fix", "Planear corrección"), ("confirm", "Pedir confirmación"), ("edit_file", "Aplicar corrección"), ("restart", "Reiniciar servidor"), ("verify", "Verificar que se corrigió"), ("report", "Reportar resultado"), ], TaskType.INSTALAR_DEPENDENCIA: [ ("analyze_project", "Detectar tipo de proyecto"), ("determine_manager", "pip o npm?"), ("run_install", "Ejecutar instalación"), ("verify_install", "Verificar instalación"), ("update_deps_file", "Actualizar requirements/package.json"), ("report", "Reportar resultado"), ], TaskType.CREAR_API: [ ("analyze_project", "Ver estructura actual"), ("detect_language", "Python o Node?"), ("plan_api", "Diseñar endpoints"), ("confirm", "Pedir confirmación"), ("create_files", "Crear archivos necesarios"), ("update_main", "Integrar con archivo principal"), ("install_deps", "Instalar dependencias"), ("restart", "Reiniciar servidor"), ("verify", "Verificar que funciona"), ("report", "Reportar resultado"), ], } MEJORA 5: CONTEXTO PERSISTENTE class AIProjectContext: """ Mantiene contexto del proyecto entre peticiones. """ def __init__(self): self.project_info = None          # Análisis del proyecto self.files_created = []           # Archivos creados en sesión self.files_modified = []          # Archivos modificados self.commands_executed = []       # Comandos ejecutados self.errors_fixed = []            # Errores corregidos self.conversation_history = []    # Historial de conversación self.current_task = None          # Tarea actual def remember_file_created(self, path: str, content: str): """Recordar que se creó un archivo""" self.files_created.append({ "path": path, "timestamp": datetime.now(), "size": len(content) }) def remember_file_modified(self, path: str, change_description: str): """Recordar que se modificó un archivo""" self.files_modified.append({ "path": path, "change": change_description, "timestamp": datetime.now() }) def get_context_summary(self) -> str: """Resumen del contexto para incluir en prompts""" return f""" CONTEXTO DEL PROYECTO: - Lenguaje: {self.project_info.get('language', 'desconocido')} - Framework: {self.project_info.get('framework', 'ninguno')} - Archivos creados esta sesión: {len(self.files_created)} - Archivos modificados esta sesión: {len(self.files_modified)} - Último archivo tocado: {self.files_modified[-1]['path'] if self.files_modified else 'ninguno'} """ MEJORA 6: SISTEMA DE VERIFICACIÓN MEJORADO class AIVerificationSystem: """ Verifica que las acciones se completaron correctamente. """ def verify_file_created(self, path: str) -> bool: """Verificar que el archivo se creó""" return os.path.exists(path) def verify_file_syntax(self, path: str) -> Dict: """Verificar sintaxis del archivo""" content = self.toolkit.read_file(path) language = self.detect_language(path) if language == "python": return self.verify_python_syntax(content) elif language == "javascript": return self.verify_js_syntax(content) # etc. def verify_server_running(self) -> bool: """Verificar que el servidor está corriendo sin errores""" logs = self.toolkit.read_server_logs(10) errors = self.toolkit.detect_errors(logs) return len(errors) == 0 def verify_endpoint_works(self, endpoint: str) -> bool: """Verificar que un endpoint responde""" try: response = requests.get(f"http://localhost:5000{endpoint}") return response.status_code < 500 except: return False def auto_fix_if_needed(self, verification_result: Dict) -> bool: """Intentar corregir automáticamente si hay problemas""" if not verification_result["success"]: for error in verification_result["errors"]: fix = self.toolkit.analyze_error(error) if fix["auto_fix_available"]: for cmd in fix["fix_commands"]: self.toolkit.run_command(cmd) return self.verify_server_running() return True ════════════════════════════════════════════════════════════════ PARTE 5: RESUMEN - LO QUE DEBES IMPLEMENTAR ════════════════════════════════════════════════════════════════ PRIORIDAD CRÍTICA (Sin esto no funciona nada): ├── 1. AIToolkit.read_file()      → Leer archivos ├── 2. AIToolkit.edit_file()      → Editar archivos ├── 3. AIToolkit.write_file()     → Crear archivos (multi-lenguaje) ├── 4. AIToolkit.run_command()    → Ejecutar comandos ├── 5. AIToolkit.read_logs()      → Ver logs/errores └── 6. IntentParser expandido     → Entender más tipos de peticiones PRIORIDAD ALTA (Para ser realmente útil): ├── 7. AIToolkit.search_code()    → Buscar en código ├── 8. AIToolkit.list_directory() → Ver estructura ├── 9. AIToolkit.analyze_project()→ Entender el proyecto ├── 10. AIVerificationSystem      → Verificar que todo funciona └── 11. AIProjectContext          → Recordar lo que se hizo PRIORIDAD MEDIA (Para ser excelente): ├── 12. Auto-corrección de errores ├── 13. Generación multi-lenguaje (Python, Node, SQL) ├── 14. Sistema de diff visual └── 15. Memoria persistente entre sesiones